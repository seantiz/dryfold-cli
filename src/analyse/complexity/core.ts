import fs from 'fs'
import Parser from 'tree-sitter'
import Cpp from 'tree-sitter-cpp'
import type { ComplexityValues } from "../../schema"
import { findMethods } from './findMethods'
import { calculateControlFlowTime, calculateTemplateComplexity } from './utils'
import type { Tree } from 'tree-sitter'

const parser = new Parser()
parser.setLanguage(Cpp)

export function analyseCppFile(cppFile: string): ComplexityValues {
    try {
        const code = fs.readFileSync(cppFile, 'utf-8')
        if (!code || code.length === 0) {
            return {
                error: 'Empty file',
                includes: [],
                complexity: null
            }
        }

        // We cannot parse complex files or tree-sitter will invalidate the whole job
        if (code.includes('/* This file is generated') ||
            code.includes('/* This is an automatically generated table') ||
            code.includes('// Generated by') ||
            code.includes('regenerated')) {
            return {
                includes: [],
                complexity: null,
                error: 'Skipped generated/table file'
            }
        }

        // Match headers to our ad-hoc complexity score and skip high-scoring files
        const pragmaCount = (code.match(/#pragma/g) || []).length
        const classCount = (code.match(/\bclass\s+\w+/g) || []).length
        const deletedMethodCount = (code.match(/\bdelete\b/g) || []).length

        if (pragmaCount > 2 && classCount > 5 ||
            classCount > 10 ||
            deletedMethodCount > 5) {
            return {
                includes: [],
                complexity: null,
                error: 'Skipped generated/table file'
            }
        }

        // Skip Cpp files that map hex tables
        const hexMapPattern = /{\s*0x[0-9a-fA-F]+\s*,\s*["'][^"']+["']\s*}/g
        const matches = code.match(hexMapPattern)
        if (matches && matches.length > 10) {
            return {
                includes: [],
                complexity: null,
                error: 'Skipped hex mapping table file'
            }
        }

        // Begin building dependencies map for each valid file

        const tree = parser.parse(code)

        const dependencies: ComplexityValues = {
            includes: [],
            complexity: {
                metrics: {
                    loc: 0,
                    functions: 0,
                    classes: 0,
                    templates: 0,
                    conditionals: 0,
                    loops: 0,
                    includes: 0
                },
                complexityScore: 0,
                estimatedTime: {
                    hours: 0,
                    minutes: 0
                },
                methods: {
                    localFunctions: [],
                    callbacks: [],
                },
                tree: tree
            }
        }

        tree.rootNode.descendantsOfType('preproc_include').forEach((node) => {
            const headerNode = node.descendantsOfType('string_literal')[0] ||
                node.descendantsOfType('system_lib_string')[0]
            if (headerNode) {
                const headerPath = headerNode.text.replace(/[<>"]/g, '')
                dependencies.includes.push(headerPath)
            }
        })

        // Inject complexity analysis to the map for the complexity report
        dependencies.complexity = findTaskComplexity(cppFile, code, tree)

        return dependencies

    } catch (error) {
        console.error(`AnalyseCFile error when reading ${cppFile}:`, error)
        return {
            error: error as string,
            includes: [],
            complexity: null
        }
    }
}

function findTaskComplexity(cppFile: string, code: string, tree: Tree) {
    const metrics = {
        loc: code.split('\n').length,
        functions: 0,
        classes: 0,
        templates: 0,
        conditionals: 0,
        loops: 0,
        includes: 0
    }

    const classTimeMetrics = {
        core: 0,
        utility: 0,
        base: 0,
        derived: 0
    }

    tree.rootNode.descendantsOfType('function_definition').forEach(() => metrics.functions++)
    tree.rootNode.descendantsOfType('class_specifier').forEach(() => metrics.classes++)
    tree.rootNode.descendantsOfType('template_declaration').forEach(() => metrics.templates++)
    tree.rootNode.descendantsOfType('if_statement').forEach(() => metrics.conditionals++)
    tree.rootNode.descendantsOfType('for_statement').forEach(() => metrics.loops++)
    tree.rootNode.descendantsOfType('while_statement').forEach(() => metrics.loops++)
    tree.rootNode.descendantsOfType('preproc_include').forEach(() => metrics.includes++)

    const methodAnalysis = findMethods(tree)

    // Adjusted time components
    const headerFileTime = (metrics.loc * 5) / 3600 // 5 seconds per line average
    const templateTime = calculateTemplateComplexity(tree)
    const logicTime = calculateControlFlowTime(tree)

    // Additional time components for thorough testing and documentation
    const testingTime = (classTimeMetrics.core + classTimeMetrics.utility) * 0.5
    const documentationTime = (classTimeMetrics.core + classTimeMetrics.utility) * 0.3

    // Time estimates
    const totalTime =
        (headerFileTime || 0) +
        Object.values(classTimeMetrics).reduce((sum, time) => sum + (time || 0), 0) +
        (templateTime || 0) +
        (logicTime || 0) +
        (testingTime || 0) +
        (documentationTime || 0) || 0

    const hours = Math.floor(totalTime) || 0
    const minutes = Math.round((totalTime - hours) * 60) || 0

    // Complexity scoring
    const complexityScore =
        metrics.functions * 2 +
        metrics.templates * 4 +
        metrics.conditionals * 1 +
        metrics.loops * 1.5 +
        metrics.includes * 0.5

    return {
        metrics,
        complexityScore,
        estimatedTime: {
            hours,
            minutes
        },
        methods: methodAnalysis,
        tree: tree
    }
}